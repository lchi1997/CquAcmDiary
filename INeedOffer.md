1.	[ok]**TCP与UDP的区别，三次握手，四次握手**
	2. 连接: -SYN->,<-SYN+ACK-,-ACK->
	3. 断开: -FIN->,(<-DATA-)<-ACK<-(<-DATA-),<-FIN-,-ACK->
	4. 客户端:-Closed->SYN+SEND->ESTABLISED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->Closed
	5. 服务端:-LISTEN->SYN+RCVD->ESTABLISED->CLOSE_WAIT->LAST_ACK->CLOSE->LISTEN
	6. SYN用于同步报文开始的序号

2. TCP拥塞控制

2.	[ok]汇编的4个段
	3. 数据段 - DS
	4. 堆栈段 - SS
	5. 代码段 - CS
	6. 扩展段 - ES

2.	[ok]高级语言角度 程序的5个段 根据**APUE**
	3. text //代码段 可执行代码，字符串常量?
	4. data （initialized）//数据段 已初始化全局变量，全局静态变量，局部静态变量，常量数据
	5. bss //未初始化的数据段 即是 未初始化全局变量+未初始化全局静态变量
	6. stack //局部变量，函数参数
	7. heap //动态内存分配
	8. **字符串常量的存放 相当特殊复杂**
	8. 一个可执行的二进制程序=text+data+bss
	9. 正在运行的c程序=text+data+bss+stack+heap
	10. 将应用程序加载到内存空间执行时，操作系统负责代码段，数据段，BSS段的加载，并将在内存中未这些段分配空间。栈也由os分配和管理，堆由程序猿自己管理，显示申请和释放
	11. 动态和静态分配 直到**run-time**时，执行动态分配，而在compile-time的时候，就已经决定了分配多少test+data+bss+stack.

2.	[ok]APUE中典型的C内存空间分布图：high: stack->...<-heap|bss|data|text :low

3.	**地址高低等问题**

2. 虚基类

3. 当有虚函数和虚基类的时候类的内存结构是怎样的

2.	**linux常用命令**
	3. netstat 网络信息
	4. ifconfig 网卡信息
	5. wall 广播
	6. grep which cat find less touch vi rm mv cp pwd mkdir cd cp ...
	7. umask文件缺省权限？
	8. chmod
	9. ps 进程
	10. df 磁盘空间
	11. top cpu，内存占用率等
	12. kill
	13. free 内存使用情况

2. [ok]new与malloc异同
	3.	都分配在堆
	4. 完整类型指针-void*
	5. 失败抛出异常/NULL
	6. 内存大小一个计算一个显示制定字节数
	7. new调用malloc
	8. 允许函数重载
	9. 调用构造与析构函数
	10. https://blog.csdn.net/lpwstr/article/details/79683859

3.	堆和栈的区别

3.	define const 区别

3. [ok]结构体内存的对齐方式，为什么要对齐
	4. 按最大的基本类型对齐
	5. 平台原因：不是所有硬件都可以访问任意地址上的任意数据
	6. 性能原因：访问未对齐的内存时，cpu需要两次内存访问，对齐的内存只需要一次，数据结构尤其是栈应该尽可能的在自然边界上对齐

4.	分页分段

3. http状态码

3. http和https区别

4. [ok]**c++多态的实现方式，虚函数的底层实现细节**
	5. 虚函数，虚函数指针 //动态
	6. 每个对象有一个虚函数表，里面存的是虚函数的函数指针
	7. 多继承多张表
	8. 模版 //静态
	9. 重载 //静态多态
	10. 强制类型转换 //动态多态

6.	类型转换

5. [ok]继承类调用构造函数顺序和析构函数顺序

6. [ok]vector resize等 迭代器失效
	7. resize重新申请并且改变当前vector对象的有效空间大小，reserve重新申请总空间大小，多出来的未定义
	8. push_back时end肯定失效，并且如果capacity与没有插入元素之前相比有改变，则需要重新加载整个容器，first，end等通通都会失效
	9. 删除操作之后，指向删除点的迭代器和指向其后的迭代器全部失效
	10. 扩容的时候（非reserve），如果x2够用就x2，不够就需要多少给多少（一次操作）

7. map 红黑树

8. 堆

12. 数据库索引 https://www.cnblogs.com/hyd1213126/p/5828937.html

13. sql http://www.w3school.com.cn/sql/sql_constraints.asp

14. 网络模型以及各层协议，tcp的拥塞控制

15. IO复用以及select，poll，epoll区别

16. 指针和饮用的区别

17. 复杂度为nlgn的排序有哪些

18. LRU cache数据结构的实现
	1.	LinkedHashMap

19. 双向链表转二叉搜索树

20. 长短URL相互转换方案

21. [ok]进程和线程的创建 fork std::thread

22. 指针/引用

23. 智能指针/共享内存

21. (??)进程间通信 IPC
	22. 管道 可以看成一种特殊的文件，read/write，但不是普通的文件，只存在于内存中，管道中的数据被当作字节流，无法识别信息的边界
		23. 普通管道PIPE：单工 单向传输，只能在父子或者用地进程间使用
		24. 流管道s_pipe：去除了第一种限制，半双工，可以双向传输
		25. (FIFO)命名管道name_pipe：去除了第二种限制，可以在许多不相关的进程间进行通讯
		26. pipe 创建一个管道，返回两个管道描述符，用于父子进程之间的通讯
		27. popen，pclose 只返回一个管道描述符，常用于通信另一方是stdin or stdout
		28. mkpipe 创建命名管道，在许多进程之间交互
		29. 如果有多个读进程，那么写进程无法发送数据到指定的读进程，多个写进程的话，没法判断是谁发送的数据
	23. 消息队列 就是一个消息的链表，一个或多个进程向他写消息，一个或多个进程读。linux维护了一个消息队列的向量表msgque，表示系统中的所有的消息队列 struct msqid_ds *msgque[MSGMNI]
		24. 结构中包括：ipc_perm描述消息队列的通用认证方式，消息指针x2begin end，时间域x3最后一次发送时间+接收时间+改动时间，进程等待队列x2 读/写，记数域x3 当前字节数+队列中的消息数+队列中的最大字节数，PID域x2 最后一次向该消息队列发送消息的进程+最后一次从该队列接受消息的进程
		25. 四种操作：创建或获得消息队列MSGGET，发送消息，接收消息，消息控制MSGCTL(用于释放队列+获得队列的认证信息+设置队列的认证信息
	24. (??)信号 如终端中断，i/o就绪通知，异常等
	25. (??)信号量 互斥信号量，条件信号量
	25. 共享内存 通常由一个进程创建，其余进程对这块内存区进行读写
		26. 获得：
			27. 映射/dev/mem设备（不给系统带来额外的开销，控制实际的物理内存，现实中不常用）
			28. 内存映像文件
	26. 套接字socket
	27. 目的:
		28. 数据传输，共享数据，通知事件（进程终止时通知父进程），资源共享（需要内核提供锁和同步机制），进程控制（如debug进程）

22. [ok]进程与线程与协程差别
	23. 进程 是一个实体，有自己的地址空间text，data，stack
	24. 线程 是程序执行流的最小单元 （线程ID，当前指令指针PC，寄存器集合，堆栈） 系统调派和分派的基本单位 自己不拥有系统资源
	25. 协程 多个线程/协程相对独立，有自己的上下文 线程上下文切换受系统控制，协程由自己控制，由当前协程切换到其他协程由当前协程来控制
	26. 进程与线程的区别
		27. 线程是进程的一个实体
		28. 进程是资源分配的最小单位，线程是程序执行的最小单位
		29. 进程拥有独立的堆栈空间和数据段，独立的地址空间，众多的数据表来维护它的代码段，堆栈段，数据段，系统开销很大
		30. 线程拥有独立的栈空间，共享**数据段???**/堆，使用共享的地址空间，比进程节俭，开销小，切换速度快，效率高
		31. 进程的安全性比较高
		32. 一个进程崩溃后，在保护模式下不会对其他进程影响，而线程只是一个进程中的不同执行路径，一个线程死掉就全死
		33. 进程通信复杂
		34. 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符
		35. 线程又称轻量级进程，进程有PCB，线程有线程控制块TCB
		36. 1对多

22. [ok]进程和线程的存储 PCB TCP
	23. PCB = 
		24. 进程标识(本进程标识(执行了几次)+产生者/父进程标识+用户标识)
		25. +处理机状态信息保存区(主要是寄存器，保存进程的运行现场的信息 =用户可见寄存器/用户使用的数据/地址+控制和状态寄存器/程序计数器pc/程序状态字PSW+栈指针(过程调用/系统调用/中断处理和返回时需要用到))
		26. +进程控制信息
			27. 调度和状态信息 //运行状态等
			28. 进程间通信信息
			29. 进程本身的存储管理信息 //本进程映像存储空间的数据结构，内存信息
			30. 进程所用资源 //如文件
			31. 有关数据结构的连接信息 //父子进程链
	24. PCB组织方式:链表(便于插删，用于通用的os，统一状态的进程PCB为一个链表，多个状态对应多个不同的链表，如就绪链表，阻塞链表) or 索引表(数组，不利于插删，使用于固定数目的进程，相对于创建更快捷,统一状态的归入一个index表，就绪/阻塞索引表)
	25. TCB = PC + SP堆栈 + state状态 + 寄存器
	26. 线程 = 进程 - 共享资源，只共享text，data，打开的资源?

22. **线程的实现 & 用户级线程/内核级线程**
	23. 3种：用户线程+内和线程+轻量级进程(内核中实现，支持用户线程)
	24. 用户线程与内和线程:多对1，1对1，多对多

23. 协程的实现

22. API与系统调用的区别

22. 中断，

23. 多线程和多进程
	25. 总线程数<=CPU数量：并行运行
	26. 总线程数>CPU数量：并发运行

22. 进程的上下文切换 context switch

22. [ok]线程上下文切换
	23. cpu给每个线程分配时间片来实现，一个时间片一般几十ms
	24. 时间片分配算法
	25. 任务从保存到再加载的过程
	26. 对线程的上下文进行切换的过程
	27. 会带来额外的开销=上下文信息保存和恢复的开销+线程进行调度的cpu时间开销以及cpu缓存失效的开销

22. 缓存 cache机制

22. [ok]进程组
	23. 每个进程属于一个进程组
	24. 每个进程组有一个进程组号，该号等于该进程组组长的PID号
	25. 一个进程智能为它自己或者子进程设置进程组ID号
	26. 作用：方便管理这些进程，比如可以一口气杀死所有进程组内的进程
	27. getpgrp / getpgid / setpgid ?

22. 会话期(seesion) ???
	23. 一个或多个进程组的集合
	24. setsid()可建立一个对花期，如果setsid的进程不是一个进程组的组长，此函数创建一个新的会话期
		25. 此进程变成会话期首进程
		26. 此进程变成一个新进程组的组长进程
		27. 此进程没有控制终端，如果再调用setsid前，该进程有控制终端，那么与该终端的联系被解除。如果该进程是一个进程组的组长，此函数返回错误。
		28. 为了保证这一点，线fork然后exit，此时只有子进程

22. 守护进程Daemon
	23. 概念: 运行在后台的一种特殊进程，独立于控制终端并且周期性地执行某种任务或等待处理某些发生的时间。不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。linux大多数服务器就是通过守护进程实现的。常见:syslogd,httpd,sendemail,mysqld
	24. 创建: 
		25. 父进程fork后exit
		26. 子进程中调用setsid创建新的会话
			27. 注：目的是脱离终端，setsid后创建了新的会话，离开了原所属的终端管理的会话，就不会被终端管理了
		27. 子进程中调用chdir函数，让根目录成为子进程的工作目录
		28. 子进程中调用umask函数，设置进程的umask为0
			29. 注：进程从父进程继承了文件创建掩模，能修改守护进程所创建的文件的存取为，为防止这一点，清楚它
		29. 在子进程中关闭任何不需要的文件描述符
		30. 可处理SIGCHILD信号？？？？signal(SIGCHLD,SIG_IGN)，？？？对于某些进程，如果父进程不等待子进程结束，子进程将会成为僵尸进程从而占用系统资源。如果等待则会增加父进程的负担，影响并发性能。????
		30. 未避免它重新申请终端，可再次创建子进程，此时子进程不再是会话组组长。不会申请控制终端

22. [ok]僵尸进程和孤儿进程
	23. 正常情况下需要wait，waitpid系统调用获得子进程的终止状态
	23. 孤儿进程：父进程退出，多个子进程却还在运行
	24. 僵尸进程：如果fork创建子进程后，子进程退出但是父进程没有调用wait或者waitpid获取子进程状态信息，那么子进程的进程描述符会仍然保存在系统中，这种进程被称之为僵尸进程 // 主要进程号有限，大量占用可能导致系统不能产生新的进程

22. [ok]linux进程与控制终端，登陆会话与进程组关系
	23. 进程属于一个进程组，进程组号GID就是进程组长的进程号PID，登陆会话可以包含多个进程组，这些进程组共享一个控制终端，这个控制终端通常是创建进程的登录终端

23. 线程的状态 就绪/阻塞/运行

23. 设计模式 单例模式，工厂模式等

24. HashMap实现，两个map的区别

25. 进程调度，上下文

26. 线程安全

27. 死锁,银行家算法

28. 乐观锁，悲观锁

29. Union和UnionAll的区别 (去重

30. 索引与主键的区别

31. 惊群效应

32. pragma

33. consul rpc ...

34. radis与memcache的区别

35. http与https的区别

37. 数据库范式

38. 进程的状态转换图

40. atomic