1.	[ok]**TCP与UDP的区别，三次握手，四次握手**
	2. 连接: -SYN->,<-SYN+ACK-,-ACK->
	3. 断开: -FIN->,(<-DATA-)<-ACK<-(<-DATA-),<-FIN-,-ACK->
	4. 客户端:-Closed->SYN+SEND->ESTABLISED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->Closed
	5. 服务端:-LISTEN->SYN+RCVD->ESTABLISED->CLOSE_WAIT->LAST_ACK->CLOSE->LISTEN
	6. SYN用于同步报文开始的序号

2. 报文相关
	3. 最大报文段长度 MSS
	4. MSS协商
	5. RTT 传输往返时间,RTO 超时计时器重传时间 = (1-alpha)xRTT旧+alphaxRTT新

2. [ok]TCP拥塞控制/流量控制
	3. 流量控制 指的是点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以使接收端来得及接收
		4. ***滑动窗口***
			5. A向B发送数据，B告诉A窗口大小rwnd
			6. A发送 seq=i,DATA 直到窗口大小发光
			7. 如果发生错误，B只ack前面连续的报文
		2.	Nagle算法
			3. 若发送方把要发送的数据住个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节缓存起来，收到第一个数据字符的确认后才继续发送下一个报文段。
			4. 当数据到达较快而网速较慢时，这样可以明显减少所用的网络带宽
			5. 另外规定：当到达的数据已经到达发送窗口大小的一半或者已经到达报文段的最大长度时，立刻发送一个报文段
		3. 糊涂窗口综合证:
			4. TCP接收方缓存已满，而交互式应用程序一次只从接受缓存中读取1字节，然后向发送方发送确认，并且把窗口设置为1个字节(但是发送的数据报为40个字节的话)。接收，发送方又发来一个字节的数据(发送方的IP数据报是41字节)。接收方确认，仍将窗口设置为1，这样导致网络效率极低，大部分都浪费了。
			5. 解决：可以让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已经有一半的空闲的空间。发送方也可以不发送太小的报文段，而是把数据报积累成足够大的报文段，或者达到接收方缓存的空间的一半大小
	2.	拥塞控制 防止过多的数据注入到网络中，这样可以使的网络中的路由器链路不至于过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。这是一个全局性的过程
		3. 拥塞：即是对资源的需求超过了可用的资源。若网络终于多资源同时供应不足，网络的性能就会明显变坏，整个网络的吞吐量随之负荷的增大而下降
		4. 拥塞控制代价：需要获得网络内部流量分布的信息
		5. 相关算法
			6. 慢开始slow-start
				7. 当主机开始发送数据时，如果立即大量数据字节注入到网络，那么就有可能引起网络拥塞，因为并不清楚网络的负荷情况。从小到大逐渐增大拥塞窗口。刚开始时可将cwnd设置为一个最大报文段MSS的数值，每收到一个新的ack后增加至多一个MSS的数值，这样逐步增大发送方的拥塞窗口
				8. **慢开始门限ssthresh状态变量** //用于防治cwnd增长过大引起阻塞
					1. 当cwnd<ssthresh 使用慢开始算法
					2. 当cwnd>ssthresh 停止使用慢开始而使用拥塞避免算法
					3. 当cwnd=ssthresh 都可以
			7. 拥塞避免congestion avoidance
				8. 让cwnd缓慢增大，没经过一个往返时间RTT就把发送方的拥塞窗口+1
				9. 另外包含在慢开始阶段，一旦网络出现拥塞（依据没有收到ack）就把慢开始门限设置为出现拥塞时发送方窗口值的一半（但不小于2），然后把cwnd重新设置为1，执行慢开始算法 //设为1目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕
			8. 快重传fast retransmit
				9. 不再拥塞时把cwnd=1
				1. 首先要求接收方每收到一个失序的报文段就立即发出重复确认，使得发送方及早知道有报文段没有到达对方，而不要等到自己发送数据时才进行捎带确认
				2. 收到3个重复确认后立刻重传下一个包
				3. 快重传可以使整个网络的吞吐量增加约20%
			9. 快恢复fast recovery
				1. 当连续收到三个重复确认，就执行乘法减小，减半ssthresh。但是接下去不执行慢开始
				2. 把cwnd设置为慢开始门限ssthresh减半后的数值，然后执行拥塞避免算法
		10. 拥塞窗口
			11. 发送方维持一个拥塞窗口cwnd(congestion window)的状态变量。窗口大小取决于网络的拥塞程度，并且动态地在变化，发送方让自己的发送窗口等于拥塞
			12. 拥有发送窗口的原则：只要网络没有出现拥塞，拥塞窗口就大一些，但只要网络出现拥塞，拥塞窗口就小一些，以减少注入到网络中的分组数
		1.	TCP Tahoe版本使用慢开始(已废弃不用)，TCP Reno版本使用快恢复
		2. 发送窗口的上线=min(rwnd,cwnd)

2.	[ok]汇编的4个段
	3. 数据段 - DS
	4. 堆栈段 - SS
	5. 代码段 - CS
	6. 扩展段 - ES

2.	[ok]高级语言角度 程序的5个段 根据**APUE**
	3. text //代码段 可执行代码，字符串常量?
	4. data （initialized）//数据段 已初始化全局变量，全局静态变量，局部静态变量，常量数据
	5. bss //未初始化的数据段 即是 未初始化全局变量+未初始化全局静态变量
	6. stack //局部变量，函数参数
	7. heap //动态内存分配
	8. **字符串常量的存放 相当特殊复杂**
		91. int a=0; //data
		10. char *p1; //bss
		11. main(){
		12. int b; //stack
		13. char s[] = "abc"; //stack
		14. char *p2; //stack
		15. char *p3 = "123"; //123\0在data常量区，p3在stack
		16. static int c = 0; //data
		17. p1 = (char*)malloc(10); //heap
		18. strcpy(p1,"123456"); //123456\0 data
		19. ...
	8. 一个可执行的二进制程序=text+data+bss
	9. 正在运行的c程序=text+data+bss+stack+heap
	10. 将应用程序加载到内存空间执行时，操作系统负责代码段，数据段，BSS段的加载，并将在内存中未这些段分配空间。栈也由os分配和管理，堆由程序猿自己管理，显示申请和释放
	11. 动态和静态分配 直到**run-time**时，执行动态分配，而在compile-time的时候，就已经决定了分配多少test+data+bss+stack.

2.	[ok]APUE中典型的C内存空间分布图：high: stack->...<-heap|bss|data|text :low

3.	**地址高低等问题**

2. 虚基类
	3. class a : virtual public base
	4. 主要解决多重继承时的菱形继承问题

3. 当有虚函数和虚基类的时候类的内存结构是怎样的

2.	**linux常用命令**
	3. netstat 网络信息
	4. ifconfig 网卡信息
	5. wall 广播
	6. grep which cat find less touch vi rm mv cp pwd mkdir cd cp ...
	7. umask文件缺省权限？
	8. chmod
	9. ps 进程
	10. df 磁盘空间
	11. top cpu，内存占用率等
	12. kill
	13. free 内存使用情况
	14. comm diff 比较文件差异

2. [ok]new与malloc异同
	3.	都分配在堆
	4. 完整类型指针-void*
	5. 失败抛出异常/NULL
	6. 内存大小一个计算一个显示制定字节数
	7. new调用malloc
	8. 允许函数重载
	9. 调用构造与析构函数
	10. https://blog.csdn.net/lpwstr/article/details/79683859

3.	[ok]堆和栈的区别
	4. 栈由操作系统管理，堆由程序猿控制
	5. 堆分配速度慢，地址不连续，容易碎片化
	6. 申请堆内存时，系统会遍历一个记录空闲内存地址的链表，寻找第一个空间大雨所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并分配给程序
	7. 栈速度快，使用方便，分配失败会导致栈溢出作用
	8. 大小：windows下栈的容量有限1-2M，堆受限于计算机有效虚拟内存

3.	[ok]define const 区别
	4. const带类型
	5. define只是简单的字符替换，容易出问题（优先级）语义错误，没有类型检查
	6. define在预处理阶段起作用，const在编译运行时候起作用
	7. define占用text段，const占用data段
	8. define不能进行调试
	9. const不能重定义，define可以undefine
	10. define可以用来防治文件重复引用，const不能

3. [ok]结构体内存的对齐方式，为什么要对齐
	4. 按最大的基本类型对齐
	5. 平台原因：不是所有硬件都可以访问任意地址上的任意数据
	6. 性能原因：访问未对齐的内存时，cpu需要两次内存访问，对齐的内存只需要一次，数据结构尤其是栈应该尽可能的在自然边界上对齐

4.	分页分段

3. http状态码

3. http和https区别

4. [ok]**c++多态的实现方式，虚函数的底层实现细节**
	5. 虚函数，虚函数指针 //动态
	6. 每个对象有一个虚函数表，里面存的是虚函数的函数指针
	7. 多继承多张表
	8. 模版 //静态
	9. 重载 //静态多态
	10. 强制类型转换 //动态多态

6.	[ok]类型转换
	7. static_cast<int>(a) 完成编译器认可的隐式类型转换
	8. dynamic_cast 执行派生类指针或引用与基类指针或引用之间的转换
		9. dynamic_cast 是运行时处理，运行时类型检查
		10. 基类中要有虚函数，运行时类型检查的类型信息在虚函数表中，有虚函数才会有虚函数表
		11. 可以实现向上或向下转型，但必须是public或者protected继承
	9. const_cast
		10. 只能针对指针或者引用去除或者添加const属性，对于变量直接类型不能const_cast,不能用于不同类型之间的转换，只能改变同种类型的const属性
	11. reinterpret_cast
		12. 重新解释的类型转换，任意两个类型之间的变量我们都可以使用reinterpret_cast在他们之间相互转换，无视类型信息
		13. 不常用

5. [ok]继承类调用构造函数顺序和析构函数顺序

6. [ok]vector resize等 迭代器失效
	7. resize重新申请并且改变当前vector对象的有效空间大小，reserve重新申请总空间大小，多出来的未定义
	8. push_back时end肯定失效，并且如果capacity与没有插入元素之前相比有改变，则需要重新加载整个容器，first，end等通通都会失效
	9. 删除操作之后，指向删除点的迭代器和指向其后的迭代器全部失效
	10. 扩容的时候（非reserve），如果x2够用就x2，不够就需要多少给多少（一次操作）

7. ***map 红黑树***

8. **map是从小到大顺序遍历的**

8. ***堆***

1. [ok]***B+树***
	2. 是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树
	3. 至少2个节点
	3. B+树分支树=索引数，B树分支数=索引数+1
	4. 相比B树 IO次数更少，查询性能稳定，范围查询简便
	5. 有k鸽子树的中间节点包含k个元素(B树k-1个)，元素不保存数据，数据在叶子结点
	6. 叶子结点本身按关键字大小自小而大顺序链接
	7. 所有中间节点的元算同时存在于子节点，在子节点元素中是最大的
	8. 插入：
		9. 找下去直接插入
		10. 如果破坏了B+树的性质，分成两半，并且向父节点加
		11. 父节点如果又违反了B+树性质就继续递归上一个操作
	12. 删除:
		13. 如果删除了最大节点，需要修改父节点上的这个值
		14. 若果违反了B+树性质，先尝试从兄弟借，如果借了还是违反则进行合并兄弟节点

12. 数据库索引
	13. 聚集索引clustered index    类似字典结构
	14. 非聚集索引nonclustered index   也成为二级索引，辅助索引
	15. 索引类型
		16. 普通索引 大多数情况下使用的
		17. 唯一索引 索引的列值必须唯一或者空
		18. 全文索引 尽可以适用于MyISAM引擎的数据表;作用于CHAR，VARCHAR，TEXT数据类型的列
		19. 组合索引 将几个列作为一条索引进行检索，使用最左匹配原则
	15. 索引结构都是B+树，聚集索引的叶子结点存放数据，非聚集索引叶子结点存放的事非聚集索引的key和主键值。B+树的高度为索引的高度
	16. 索引的高度：聚集索引的高度决定了根据主键取数据的理论IO次数。
	17. 慢查询：指sql查询的事件超过了预设的慢查询定义时间
		18. Show variables like "long%" 来查询慢查询的事件定义
	19. =等值查询 >,<,between,in范围查询 like模糊查询 and交集查询 or并集查询
	15. ***索引命中规则***
		16. 一条sql会不会走索引一个看条件使用的运算符，另一个看有没有索引，与IN，OR，group by没关系
			17. or只在前后两个条件都有索引整个sql才会使用索引
			18. 如果一个条件没有使用索引时建议使用union
				19. 如: select * from . where a = 1 union select * from . where b = 2
			19. 不走索引的运算符<>,!=
		17. ***最左匹配原则***
			17. 先定位该sql的查询条件，有哪些，哪些是等值的，哪些是范围的条件
			18. ***等值的条件去命中索引最左边的一个字段，然后一次从左往右命中，直到遇到范围查询就停止匹配***
			19. ***如 a=1 and b=2 and c>3 and d=4，如果建立(a,b,c,d)的索引，则d用不到索引，(a,b,d,c)则都会用到索引***
		20. 等于=和in可以乱序，mysql会自动优化
		21. 索引列不能参与运算
		22. ***单个多列组合索引和多个单列索引的检索查询效果不同 ??????***
		16. 一条sql语句提交给数据库查询前需要经历：
			17. 现在where解析这一步把当前的查询语句中的查询条件分解成每一个独立的条件单元
			18. mysql会自动将sql拆分重组
			19. where条件会在B树 index这部分进行索引匹配，如果命中索引，就会跳到指定的table records位置，没有命中就只能采用全部扫描的方式
			20. 根据当前查询字段返回对应的数据值
	21. expain select * from ... 分析sql执行计划
		22. select_type 查询类型
		23. table 输出结果的表
		24. type 标识mysql在表中找到所需行的方式，或者叫访问类型
			25. all | 全表扫描
			26. index | 索引全扫描
			27. range | 索引范围扫描
			28. ref | 使用非唯一索引或唯一索引的前缀扫描，返回匹配某个单独值的记录行
			29. eq_ref | 类似于ref，使用唯一索引
			30. const/system | 单表中最多有一个匹配行，主要用于比较primary key 或者 unique，因为数据都是唯一的
			30. NULL | 不用访问表或者索引就能得到结果
		31. possible_keys 可能使用的索引列表
		32. key 实现执行使用索引列表
		33. ref 显示使用哪个列或者常数与key一起从表中选择行
		34. row 执行查询的行数
		35. extra 包含mysql解决查询的详细信息

13. sql http://www.w3school.com.cn/sql/sql_constraints.asp

13. 数据库查询优化器

14. 网络模型以及各层协议

15. IO复用以及select，poll，epoll区别

16. [ok]指针和引用的区别
	17. 有const指针，无const引用
	18. 指针可以多级，引用仅1级
	19. 指针值可以为空，引用不行，并且在定义的时候必须初始化
	20. 指针的值在初始化后可以改变，引用不行
	21. sizeof 引用是所指向对象的大小，指针则返回指针本身的大小
	22. 指针和引用的自增++运算意义不一样

17. [ok]复杂度为nlgn的排序有哪些
	18. nlgn:快排，堆排，归并
	19. n*1.3:希尔
	20. n:桶排

18. LRU cache数据结构的实现
	1.	LinkedHashMap

19. 双向链表转二叉搜索树

20. 长短URL相互转换方案

21. [ok]进程和线程的创建 fork std::thread

23. 智能指针/共享内存

21. (??)进程间通信 IPC
	22. 管道 可以看成一种特殊的文件，read/write，但不是普通的文件，只存在于内存中，管道中的数据被当作字节流，无法识别信息的边界
		23. 普通管道PIPE：单工 单向传输，只能在父子或者用地进程间使用
		24. 流管道s_pipe：去除了第一种限制，半双工，可以双向传输
		25. (FIFO)命名管道name_pipe：去除了第二种限制，可以在许多不相关的进程间进行通讯
		26. pipe 创建一个管道，返回两个管道描述符，用于父子进程之间的通讯
		27. popen，pclose 只返回一个管道描述符，常用于通信另一方是stdin or stdout
		28. mkpipe 创建命名管道，在许多进程之间交互
		29. 如果有多个读进程，那么写进程无法发送数据到指定的读进程，多个写进程的话，没法判断是谁发送的数据
	23. 消息队列 就是一个消息的链表，一个或多个进程向他写消息，一个或多个进程读。linux维护了一个消息队列的向量表msgque，表示系统中的所有的消息队列 struct msqid_ds *msgque[MSGMNI]
		24. 结构中包括：ipc_perm描述消息队列的通用认证方式，消息指针x2begin end，时间域x3最后一次发送时间+接收时间+改动时间，进程等待队列x2 读/写，记数域x3 当前字节数+队列中的消息数+队列中的最大字节数，PID域x2 最后一次向该消息队列发送消息的进程+最后一次从该队列接受消息的进程
		25. 四种操作：创建或获得消息队列MSGGET，发送消息，接收消息，消息控制MSGCTL(用于释放队列+获得队列的认证信息+设置队列的认证信息
	24. (??)信号 如终端中断，i/o就绪通知，异常等
	25. (??)信号量 互斥信号量，条件信号量
	25. 共享内存 通常由一个进程创建，其余进程对这块内存区进行读写
		26. 获得：
			27. 映射/dev/mem设备（不给系统带来额外的开销，控制实际的物理内存，现实中不常用）
			28. 内存映像文件
	26. 套接字socket
	27. 目的:
		28. 数据传输，共享数据，通知事件（进程终止时通知父进程），资源共享（需要内核提供锁和同步机制），进程控制（如debug进程）

22. [ok]进程与线程与协程差别
	23. 进程 是一个实体，有自己的地址空间text，data，stack
	24. 线程 是程序执行流的最小单元 （线程ID，当前指令指针PC，寄存器集合，堆栈） 系统调派和分派的基本单位 自己不拥有系统资源
	25. 协程 多个线程/协程相对独立，有自己的上下文 线程上下文切换受系统控制，协程由自己控制，由当前协程切换到其他协程由当前协程来控制
	26. 进程与线程的区别
		27. 线程是进程的一个实体
		28. 进程是资源分配的最小单位，线程是程序执行的最小单位
		29. 进程拥有独立的堆栈空间和数据段，独立的地址空间，众多的数据表来维护它的代码段，堆栈段，数据段，系统开销很大
		30. 线程拥有独立的栈空间，共享**数据段???**/堆，使用共享的地址空间，比进程节俭，开销小，切换速度快，效率高
		31. 进程的安全性比较高
		32. 一个进程崩溃后，在保护模式下不会对其他进程影响，而线程只是一个进程中的不同执行路径，一个线程死掉就全死
		33. 进程通信复杂
		34. 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符
		35. 线程又称轻量级进程，进程有PCB，线程有线程控制块TCB
		36. 1对多
	37. 线程与协程的差别
		38. 协程不需要锁，因为非抢占，在主动交出cpu前不会切换

22. [ok]进程和线程的存储 PCB TCP
	23. PCB = 
		24. 进程标识(本进程标识(执行了几次)+产生者/父进程标识+用户标识)
		25. +处理机状态信息保存区(主要是寄存器，保存进程的运行现场的信息 =用户可见寄存器/用户使用的数据/地址+控制和状态寄存器/程序计数器pc/程序状态字PSW+栈指针(过程调用/系统调用/中断处理和返回时需要用到))
		26. +进程控制信息
			27. 调度和状态信息 //运行状态等
			28. 进程间通信信息
			29. 进程本身的存储管理信息 //本进程映像存储空间的数据结构，内存信息
			30. 进程所用资源 //如文件
			31. 有关数据结构的连接信息 //父子进程链
	24. PCB组织方式:链表(便于插删，用于通用的os，统一状态的进程PCB为一个链表，多个状态对应多个不同的链表，如就绪链表，阻塞链表) or 索引表(数组，不利于插删，使用于固定数目的进程，相对于创建更快捷,统一状态的归入一个index表，就绪/阻塞索引表)
	25. TCB = PC + SP堆栈 + state状态 + 寄存器
	26. 线程 = 进程 - 共享资源，只共享text，data，打开的资源?

22. **线程的实现 & 用户级线程/内核级线程**
	23. 3种：用户线程+内和线程+轻量级进程(内核中实现，支持用户线程)
	24. 用户线程与内和线程:多对1，1对1，多对多

23. 协程的实现

22. API与系统调用的区别
	23. 系统调用：内核提供
	24. API
		25. 用户级API
		26. 内核级API

22. [ok]回调函数:一个通过函数指针调用的函数，实际上就是再调用某个函数时，将自己的一个函数的地址作为参数传递给那个函数，在适当时候运行

22. [ok]中断，异常
	23. 中断interruption: 外中断，来自CPU执行指令以外的事件的发生
		24. I/O结束中断
		25. 时钟中断
		26. ...
	24. 异常exception: 内中断，例外，陷入(trap)，源自CPU执行指令内部的事件
		25. 非法操作码，地址越界，算数溢出，虚存系统的缺页以及专门的陷入指令等引起的事件
		26. 异常不能被屏蔽，一旦出现应立即处理

23. 多线程和多进程
	25. 总线程数<=CPU数量：并行运行
	26. 总线程数>CPU数量：并发运行

22. 进程的上下文切换 context switch

22. [ok]线程上下文切换
	23. cpu给每个线程分配时间片来实现，一个时间片一般几十ms
	24. 时间片分配算法
	25. 任务从保存到再加载的过程
	26. 对线程的上下文进行切换的过程
	27. 会带来额外的开销=上下文信息保存和恢复的开销+线程进行调度的cpu时间开销以及cpu缓存失效的开销

22. 缓存 cache机制

22. [ok]进程组
	23. 每个进程属于一个进程组
	24. 每个进程组有一个进程组号，该号等于该进程组组长的PID号
	25. 一个进程智能为它自己或者子进程设置进程组ID号
	26. 作用：方便管理这些进程，比如可以一口气杀死所有进程组内的进程
	27. getpgrp / getpgid / setpgid ?

22. 会话期(seesion) ???
	23. 一个或多个进程组的集合
	24. setsid()可建立一个对花期，如果setsid的进程不是一个进程组的组长，此函数创建一个新的会话期
		25. 此进程变成会话期首进程
		26. 此进程变成一个新进程组的组长进程
		27. 此进程没有控制终端，如果再调用setsid前，该进程有控制终端，那么与该终端的联系被解除。如果该进程是一个进程组的组长，此函数返回错误。
		28. 为了保证这一点，线fork然后exit，此时只有子进程

22. 守护进程Daemon
	23. 概念: 运行在后台的一种特殊进程，独立于控制终端并且周期性地执行某种任务或等待处理某些发生的时间。不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。linux大多数服务器就是通过守护进程实现的。常见:syslogd,httpd,sendemail,mysqld
	24. 创建: 
		25. 父进程fork后exit
		26. 子进程中调用setsid创建新的会话
			27. 注：目的是脱离终端，setsid后创建了新的会话，离开了原所属的终端管理的会话，就不会被终端管理了
		27. 子进程中调用chdir函数，让根目录成为子进程的工作目录
		28. 子进程中调用umask函数，设置进程的umask为0
			29. 注：进程从父进程继承了文件创建掩模，能修改守护进程所创建的文件的存取为，为防止这一点，清楚它
		29. 在子进程中关闭任何不需要的文件描述符
		30. 可处理SIGCHILD信号？？？？signal(SIGCHLD,SIG_IGN)，？？？对于某些进程，如果父进程不等待子进程结束，子进程将会成为僵尸进程从而占用系统资源。如果等待则会增加父进程的负担，影响并发性能。????
		30. 未避免它重新申请终端，可再次创建子进程，此时子进程不再是会话组组长。不会申请控制终端

22. [ok]僵尸进程和孤儿进程
	23. 正常情况下需要wait，waitpid系统调用获得子进程的终止状态
	23. 孤儿进程：父进程退出，多个子进程却还在运行
	24. 僵尸进程：如果fork创建子进程后，子进程退出但是父进程没有调用wait或者waitpid获取子进程状态信息，那么子进程的进程描述符会仍然保存在系统中，这种进程被称之为僵尸进程 // 主要进程号有限，大量占用可能导致系统不能产生新的进程

22. [ok]linux进程与控制终端，登陆会话与进程组关系
	23. 进程属于一个进程组，进程组号GID就是进程组长的进程号PID，登陆会话可以包含多个进程组，这些进程组共享一个控制终端，这个控制终端通常是创建进程的登录终端

23. 线程的状态 就绪/阻塞/运行

23. 设计模式 单例模式，工厂模式等

24. HashMap实现，两个map的区别

25. 进程调度，上下文

26. 线程安全

27. 死锁,银行家算法

28. 乐观锁，悲观锁

29. Union和UnionAll的区别 (去重

30. 索引与主键的区别

31. 惊群效应

32. [ok]pragma
	33. message("消息")
	34. code_seg(["section-name" [, "section-class"]]) 可以设置程序中函数代码存放的代码段
	35. once
	36. hdrstop 与编译头到此为止
	37. resource "*.dfm" 把文件中的资源加入工程???
	38. warning(disable:4507;once:4385;error:164) 不显示哪些消息，只显示一次，或者将某个指令视为error
	39. warning(push) 保存所有警告信息的现有的警告状态
	40. warning(push,n) 保存。。。，并且把全局警告等级设定为n
	41. warning(pop) 弹出最后一个警告信息,在入栈和出栈之间的一切改动取消
	42. comment(commen-type,["commentstring"]) 将一个注释记录放入一个对象文件或可执行文件中 comment-type是一个预定义的标识符，为compiler,exestr,lib,linker之一，string是附加信息
		43. compiler 放置编译器的版本或者名字到一个对象文件，该选项被linker忽略
		44. exestr 在以后的版本将被取消
		45. lib 放置一个库搜索记录到对象文件中
	46. linker 指定一个连接选项/DEFAULTLIB,/EXPORT,/INCLUDE,/MANIFESTDEPENDENCY,/MERGE,/SECTION
	47. disable 函数前声明，只对一个函数有效，该函数再调用过程中不可被中断
	48. data_seg 建立一个新的数据段并定义共享数据
		49. #pragma data_seg("aaa")
		50. HWDNsharedwnd=NULL;//共享数据
		51. #pragma data_seg()
		52. 一般用于dll中，这个数据段中的变量可以被多个进程共享
		53. 共享数据必须初始化，否则会被放入bss段，导致共享失败
	54. region vc++特有，可折叠特定的代码块...
	55. **pack ???**

33. consul rpc ...

34. radis与memcache的区别

35. [ok]http与https的区别
	36. https加入了SSL层，更安全
	37. https需要申请ca，免费证书少，需要费用
	38. 端口不同，80，443
	39. http连接无状态，https时SSL+http构建的可进行加密传输，身份认证的网络协议

37. 数据库范式

38. 进程的状态转换图

40. atomic

41. Hive与mysql Hive 可以看成是从SQL到Map-Reduce的 映射器